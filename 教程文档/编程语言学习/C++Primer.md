# C++Primer 第五版学习
## (1) 简介
### (1.1) 输入和输出
* 1、**iostream 库**  
包含两个基础类型 istream 和 ostream ，分别表示输入流和输出流。  
一个流就是一个字符序列，是从 IO 设备读出或写入 IO 设备的。  
术语“流”​（stream）想要表达的是，随着时间的推移，字符是顺序生成或消耗的。

* 2、**标准输入输出对象**  
cin(标准输入)、cout(标准输出)、cerr(标准错误)、clog(一般信息)
```c++
// 使用方法
int num;
cin >> num; // 输入 num 的值
cout<<num<<endl; // 将 num 的值输出到标准窗口
```
* 3、**编译器检测的错误**  
语法错误、类型错误、声明错误。
## (2) c++ 基础
### (2.1) 变量和基本类型
integer、bool、char、short、long(长整型 32)、long long(长整型 64)、float、double、long double  
多数符号还可分为带符号的和不带符号的，带符号类型可以表示正数、负数或 0 ，无符号类型则仅能表示大于等于 0 的值。  
内存中一个比特位即一位，0 或 1 。**可寻址的最小内存块称为字节(byte)**，大多数机器中一个字节占 8 位，即 8 个比特位。  
**类型转换**  
比如大于 0 的值可转换为布尔值的 true 。 

C++ 程序员们在很多场合都会使用对象(object)这个名词。  
通常情况下，**对象是指一块能存储数据并具有某种类型的内存空间。**  
当对象在创建时获得了一个特定的值，我们说这个对象被初始化(initialized)了。  
**初始化不是赋值**，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。  

**声明**(declaration)使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。  
而**定义**(definition)负责创建与名字关联的实体。  
如果想声明一个变量而非定义它，就在变量名前添加关键字 extern ，而且不要显式地初始化变量：
```c++
extern int i; // 声明变量 i 而非定义 i
int j; // 声明并定义变量 j
extern float pi = 3.14; // 如果显示初始化了变量，extern 的作用就没有了，变成了定义
```
变量能且只能被定义一次，但是可以被多次声明。  

**引用和指针**   
引用(reference)为对象起了另外一个名字，**引用必须初始化**。  
引用只是别名，对引用的所有操作都是在和其绑定的对象上完成的。  
因为引用本身不是一个对象，所以不能定义引用的引用。  
```c++
int num1 = 99;
int &name = num1; // name 就是 num1 的别名
```

指针特点：  
其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。  
其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。  

指针存放某个对象的地址，要想获取该地址，需要使用取地址符(操作符 &)​
```c++
int num = 99;
int *p; // 定义指针 p ，但是没有初始化
p = &num; // p 初始化为 num 的地址
```

指针的值(即地址)应属下列 4 种状态之一:  
* 1、指向一个对象。  
* 2、指向紧邻对象所占空间的下一个位置。  
* 3、空指针，意味着指针没有指向任何对象。  
* 4、无效指针，也就是上述情况之外的其他值。  

利用指针访问对象，使用解引用符(*)
```c++
int num = 88;
int *p = &num; // 指针 p 指向 num
*p = 99; // *p 相当于 num ，将 num 的值改为 99
cout<< num <<endl; // 输出: 99
```

空指针(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。  
以下列出几个生成空指针的方法：
```c++
int *p1 = nullptr; // 推荐使用
int *p2 = 0; // 但是不能把整型变量赋给指针，即使整型变量的值为 0 ，
int *p3 = NULL; // 需要先包含 cstdlib 库，避免使用 NULL
```
空指针可以被转换为其它任意类型的指针。  
建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。  
如果实在不清楚指针应该指向何处，就把它初始化为 nullptr 或者 0 ，这样程序就能检测并知道它没有指向任何具体的对象了。  

**void*** 是一种特殊的指针类型，可用于存放任意对象的地址
```c++
double num = 3.3, *p = &num; // 指针 p 指向 double 类型的 num
void* pv = &num; // num 可以是任意类型的对象
pv = p; // pv 可以存放任意类型的指针
```
利用 void* 指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个 void* 指针。  
不能直接操作 void* 指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。  

指针也是变量，也可以定义指向指针的指针，一般只使用到二级指针。
```c++
int num = 99;
int *p1 = &num;
int **p2 = &p1; // 指针 p2 指向指针 p1
```

引用本身不是一个对象，因此不能定义指向引用的指针。  
但指针是对象，所以存在对指针的引用：
```c++
int num = 99;
int *p;
int *&r = p; // r 是指针 p 的一个引用，也就是 p 的一个别名。从右往左看
r = &num; // r 指向 num
*r = 88; // 解引用，将 num 值改为 88
cout<<num<<endl; // 输出：88
```

const 限定的对象，其值一旦创建就不能更改，所以 const 对象必须初始化。  
默认情况下， const 对象被设定为仅在文件内有效。  
当多个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量。  
如果想在多个文件之间共享 const 对象，必须在变量的定义之前添加 extern 关键字。  

**定义类型别名**
```c++
// 1、使用 typedef
typedef double dou; // dou 是 double 的别名

// 2、使用 using
using dou = double; // dou 是 double 的别名
```

auto 自动推算变量的类型，显然， auto 定义的变量必须有初始值
```c++
int num1 = 9;
int num2 = 8;
auto num3 = num1 + num2;// 自动推算出 num3 的类型为 int
```

位于头文件的代码一般来说不应该使用 using 声明。  

使用 for 进行遍历
```c++
#include<string> // 字符库
string name("dsc,,"); // name="dsc,,"
int punc_count = 0; // 用于标点符号计数
for (auto c : name)
{
	if (ispunct(c)) // 如果字符 c 是标点符号
		punc_count++;
}
cout << punc_count << endl; // 输出: 2

for (auto &c : name) // c 是引用
	c = toupper(c); // 由于 c 是引用，所以可以更改 name 中的字符
cout << name << endl; // 输出: DSC,,

for (auto &c : name) // 全部改为 x
	c = 'x'; // 由于 c 是引用，所以可以更改 name 中的字符
cout << name << endl; // 输出: xxxxx
```
### (2.2) 标准库类型
string、vector 等都是标准库，要使用需要使用头文件包含进来。  
而且 string 和 vector 都被定义在命名空间 std 中，使用时候需要声明命名空间
```c++
#include<string>
using std::string;

// 初始化字符串
string s1; // 默认初始化为空
string s2 = s1; // 拷贝赋值
string s3 = "dsc"; 
string s4(4,'f'); // 4 个 f ，即 "ffff"

// 常用的 string 对象上的操作 str.empty() str.size()
```

vector 是一个类模板。实例化过程中必须指明类型。
```c++
#include<vector>
using std::vector;

vector<int> vec; // 容器存储的类型为 int
// vector 能容纳绝大多数类型的对象作为元素，但是引用不行，因为其不是对象。

// 初始化方法
vecto<T> v1;
vector<T> v2(v1);
vector<T> v3 = v1;
vector<T> v4{a,b,c};
vector<T> v5 = {a,b,c};

// 添加元素,添加元素时，vector 会动态的改变其所占内存大小，更方便灵活
vector<int> v1;
int num1 = 9;
v1.push_back(num1); // 向容器 v1 末尾添加元素 num1

// vector 其它操作。v.empty()、v.size() 以及常用的大小比较和取下标
vector<int> v1{1,2,3,4};
for (auto &val:v1) // 使用引用改变容器中的值
	val *= val;
for(auto val : v1) // for 语句输出容器的值
	coutt<< val <<endl;
```

**vector 对象(以及 string 对象)的下标运算符可用于访问已存在的元素，而不能用于添加元素。**  
试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。  
```c++
string s; // 被初始化为空字符串
cout << s[5] << endl; // s[5] 不存在，但是编译不会出错，运行会出错
```
### (2.3) 迭代器
迭代器都有 begin 和 end 成员， begin 负责返回指向第一个元素的迭代器， end 则负责返回指向尾元素的后一个元素的迭代器。  
如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。  
**注意迭代器不是实际的对象，需要解引用才能得到对象，如果对象恰好是类，则可以进一步使用 "." 运算符或 "->" 访问类的成员。**
```c++
vector<int> v1 {1,2,3}
auto iter1 = v1.begin(), iter2 = v1.end(); // iter1 和 iter2 类型相同
for(auto it = v1.begin(); it != v1.end();it++)
	cout<< *it <<endl; // 解引用得到迭代器中的值
```
**迭代器注意事项**  
虽然 vector 对象可以动态地增长，但是也会有一些副作用。  
已知的一个限制是不能在范围 for 循环中向 vector 对象添加元素。  
另外一个限制是任何一种可能改变 vector 对象容量的操作，比如 push_back ，都会使该 vector 对象的迭代器失效。   

迭代器运算: 迭代器加或减一个数表示移动，两个迭代器相减表示两者之间的距离，也可以使用比较运算符比较两个迭代器的位置关系。  
```c++
#include<vector>
using std::vector;

vector<int> v2{ 2,3,4,5,6 };
auto mid = v2.begin() + v2.size() / 2; // 之间的迭代器
int dist = v2.begin() - v2.end(); // 越往后的迭代器所代表的位置数越大
auto iter = v2.begin() + 3; // iter 是个迭代器，指向容器中的 5
if (v2.end() > v2.begin()) // 比较位置关系
	cout << "v2.end() > v2.begin()" << endl;
cout << *mid << endl; // 输出: 4
cout << dist << endl; // 输出: -5
cout << *iter << endl; // 输出: 5
```

迭代器实现二分查找
```c++
// 二分查找
vector<int> v2{ 2,3,4,5,6 };
int num = 2;
auto ben = v2.begin(), end = v2.end();
auto mid = ben + (end - ben) / 2; // 中间迭代器的初始值
while (mid != end) // 注意循环终止条件
{
	if (*mid == num)
	{
		cout << mid - v2.begin() << endl;
		break;
	}
	else if (*mid > num)
		end = mid;
	else
		ben = mid + 1;
	mid = ben + (end - ben) / 2; // 得到新的中间迭代器
}
cout<< "don't find" <<endl;
```
### (2.4) 数组
数组是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。  
数组的大小确定不变，不能随意向数组中增加元素。  
不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。
```c++
int arr[] = { 2,3 };
int arr1[] = arr; // 错误
arr1 = arr; // 错误
```
在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针
```c++
int arr[]={1,2,3,4};
int *p = arr; // 相当于 int *p = &arr[0];
auto arr1(arr); // arr1 也是指针，指向数组首元素，相当于 auto arr1(&arr[0])
```

一个指针如果指向了某种内置类型数组的尾元素的"下一位置"​，则其具备与 vector 的 end 函数返回的与迭代器类似的功能。  
vector 容器库中， begin 迭代器指向第一个元素， end 迭代器指向尾元素的后一个元素(不能操作)。  
特别要注意，尾后指针不能执行解引用和递增操作。
标准库函数 begin 和 end 遍历数组，可以将数组作为它们的参数。
```c++
int arr[5] = { 1,2,3,4,5 };
int* ben = begin(arr);// ben 指向数组的第一个元素
int* last = end(arr); // last 指向数组最后一个元素的后一个位置，
while (ben < last)
{
	cout << *ben << endl;
	ben++;
}
```
```c++
// 比较两数组是否相等
int ar1[] = { 2,1,2,3,1 };
int ar2[] = { 1,2,3 };
int* p1 = ar1, * p2 = ar2; //两个指针分别数组首元素
int count = 0;
int len = sizeof(ar1) / sizeof(ar1[0]); //数组长度
while (*p1 == *p2)
{
	count++;
	p1++;
	p2++;
}
cout << count << endl;
```
```c++
// 比较两个 vector 对象是否相等
vector<int> vec1 = { 1,2,3,3 };
vector<int> vec2 = { 1,2,2,3 };
// 两个容器的迭代器
auto ben1 = vec1.begin(), end1 = vec1.end();
auto ben2 = vec2.begin(), end2 = vec2.end();
int count = 0;
while(*ben1 == *ben2) // 迭代器对应的元素相等
{
	count++;
	ben1++;
	ben2++;
}
cout << count << endl;
```
**建议：尽量使用标准库类型而非数组使用指针和数组很容易出错。**  
一部分原因是概念上的问题：指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误。  
其他问题则源于语法错误，特别是声明指针时的语法错误。  
现代的 C++ 程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针；  
应该尽量使用 string ，避免使用 C 风格的基于数组的字符串。

### (2.5) 表达式
**当一个对象被用作右值的时候，用的是对象的值（内容）​；**  
**当对象被用作左值的时候，用的是对象的身份（在内存中的位置）​。**  
算术运算符：+ - * / %(取余)  
关系运算符：== != > < >= <=  
逻辑运算符：&&(与) ||(或) !(非)  

关系表达式得到的结果是布尔值，不能和别的数值比较。
```c++
int i=1,j=2,k=3;
if(i < j < k) // 写法错误，i < j 得到布尔值，不能和数值 3 进行比较
```

逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，  
当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。  
这种策略称为短路求值(short-circuit evaluation)​。  
对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。  
对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。  

赋值运算符的左侧运算对象必须是一个可修改的左值。
```c++
int i=1,j=2,k=3; //初始化而赋值
const int ci=i; //初始化而非赋值
ci=k; //错误，ci 是不可修改的左值
102=num; //错误，102 不是左值
i+j=k; // 错误，算术表达式是右值
```

复合运算符：+= -= *= /= %=   

递增和递减运算符:-- ++ 
**除非必须，否则不用递增递减运算符的后置版本(比如 i++)**  
前置和后置的主要区别就是如果参与运算，前置是变量值先加 1 ，再参与运算，  
后置是变量先参与运算，再将值加 1 。  
没有参与运算的话，前置和后置一样，都是将变量值加 1 。
```c++
int i=1,n=1;
int j=++i; // j = 2 , i = 2
int k=n++; // k = 1 , n = 2
```

三目条件运算符： condition ? A : B 。condition 成立则返回 A ，否则返回 B  

位运算符：>> << &(按位与) ^(按位异或) |(按位或) ~(按位取反)
位运算符的复合式：>>= <<= &= ^= |= 
sizeof 运算符返回一条表达式或一个类型名字所占的字节数。  

**类型转换**  
C++ 语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值。  
上述的类型转换是自动执行的，无须程序员的介入，有时甚至不需要程序员了解。  
因此，它们被称作**隐式转换**(implicit conversion)​。  

**整型提升**(integral promotion)负责把小整数类型转换成较大的整数类型。  
对于 bool、char、signed char、unsigned char、short 和 unsigned short 等类型来说，  
只要它们所有可能的值都能存在 int 里，它们就会提升成 int 类型；否则，提升成 unsigned int 类型。  
就如我们所熟知的，布尔值 false 提升成 0、true 提升成 1。  

**数组转换成指针**：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。  

**强制类型转换(显示转换)** 应该避免使用
### (2.6) 语句
多数语句以分号结尾。空语句只有分号，使用时应加注释说明是空语句。  
复合语句，也叫块，一个块就是一个作用域。  

条件语句
```c++
int i=99;
if(i<2){cout<<2;}
else if(i<33){cout<<33;}
else{cout<<99;}
```

迭代语句：一般是 while 和 for  
```c++
// while
int i = 3;
while(i>0)
{
	cout<< i <<endl;
	--i;
}

// 传统 for 语句，语句中的分号必须保留
for(int j = 3; j > 0; --j){cout<< i <<endl;}

// c++11 的范围 for 语句，可遍历容器
// 格式：for(declaration : expression){statement}
int arr[]={2,3,4};
for(auto val : arr){cout<< val <<endl;}	// 打印所有元素	
for(auto &val : arr){val += 2;} // 所有元素加 2
```

**跳转语句**  
break 语句(break statement)负责终止离它最近的 while、do while、for 或 switch 语句，  
并从这些语句之后的第一条语句开始继续执行。  
continue 语句(continue statement)终止最近的循环中的当前迭代并立即开始下一次迭代。  
goto 语句(goto statement)的作用是从 goto 语句无条件跳转到同一函数内的另一条语句。避免使用。  

**try 语句块和异常处理**  
```
try{描述}
catch(表达式){处理}
catch(表达式){处理}
catch(表达式){处理}
……
```
标准异常  
* exception 头文件定义了最通用的异常类 exception 。它只报告异常的发生，不提供任何额外信息。  
* stdexcept 头文件定义了几种常用的异常类。    
* new  头文件定义了 bad_alloc 异常类型。     
* type_info 头文件定义了 bad_cast 异常类型。   
## (3) 函数
### (3.1) 函数基础
形参起到占位作用，实参是形参的初始值。  
函数的形参列表可以为空，但是不能省略。  
要想定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。  

大多数类型都能用作函数的返回类型。  
一种特殊的返回类型是 void ，它表示函数不返回任何值。  
函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。  

我们把只存在于块执行期间的对象称为自动对象(automatic object)​。  
当块的执行结束后，块中创建的自动对象的值就变成未定义的了。  
形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，  
所以一旦函数终止，形参也就被销毁。  

**局部静态对象直到程序终止才被销毁。**   

函数必须在使用前声明，只能定义一次，但可以声明多次。  
但是如果一个函数不会被用到，可以只声明，不定义。  
函数的声明相比函数定义只是用分号代替了函数体，  
而且由于没有函数体，不需要写形参类型，比如： `int func(int,int);`  

**建议函数和变量都在头文件中声明，在源文件中定义。**  

### (3.2) 参数传递
传值，传引用，传指针。  
* 传值：实参值拷贝给形参，这两个值互相独立，改变形参不影响实参。  
* 传引用：形参是引用时，形参就是实参的别名，修改其中一个，另一个随之变化。  
可避免拷贝，建议使用。  
* 传指针：如果形参是指针，实际上跟传值一样，将传入的指针进行拷贝，得到另一个指针变量，  
这个指针和传入的指针指向同一个地址，所以通过传指针可以修改所指对象的值。  
而且函数内部对指针的操作同样不影响外部的实参指针，因为改变的只是实参副本，不是原实参。  
```c++
// 传指针
void func(int*pt)
{
	*pt = 0; // 修改指针指向地址中存放的变量值
	pt = nullptr; // pt 是传入指针的副本，更改 pt 不影响外部指针。
}
int num = 99;
int *p = &num;
func(p); // 调用函数 func
cout<< *p <<endl; // 输出：0 ，指针 p 仍然指向 num ，但是函数内部的指针 pt 在调用函数时为 nullptr ，但是函数调用完之后 pt 也销毁了

// 传引用
void reset(int &val){val = 0;}
int i = 99;
int &r = i;
reset(r); // i 变为 0
cout<< i <<endl; // 输出：0
```

**数组形参**   
因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。  
因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。  

可以把形参写成数组的形式
```c++
// 这三个函数等价，每个函数的唯一形参都是 const int* 类型，
// 编译器只检查传入的参数是不是 const int* 类型
void print(const int *);
void print(const int[]);
void print(const int[6]);
```

main 函数是演示如何向函数传递数组的好例子
```c++
// argc 表示数组中字符串的数量，argv 是一个数组，它的元素是指向 c 风格字符串的指针
int main(int argc,char *argv[]){}

// 由于第二个形参是一个数组，所以 main 函数也可以写成下面的形式
int main(int argc,char **argv){} // argv 指向 char* 
// 当实参传给 main 函数之后， argv 的第一个元素指向程序的名字或者一个空字符串，
// 接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为 0 。
```
## (4) 序容器
vector(可变大小数组)、deque(双端队列)、list(双向链表)、  
forward_list(单向链表)、array(固定大小数组)、string(专门保存字符)  

## (5) 动态内存和智能指针
### (5.1) 智能指针
**new** ，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；  
**delete** ，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。  

动态内存的释放时间很难控制，忘记释放就会造成内存泄漏，  
在尚有指针引用内存的情况下如果释放就会产生引用非法内存的指针。  

**智能指针** 负责自动释放所指向的对象，包括 shared_ptr、unique_ptr、weak_ptr ，包含在头文件 memory 中    
shared_ptr 允许多个指针指向同一个对象； unique_ptr 则“独占”所指向的对象。weak_ptr 是一种弱引用，指向 shared_ptr 所管理的对象。  

类似 vector ，智能指针也是模板，所以在创建指针时，必须指定指针指向的类型。  
```c++
// 默认初始化的智能指针中保存着一个空指针
shared_ptr<int> pt; // pt 可以指向 int
shared_ptr<string> pt1; // pt1 可以指向 string
```
最安全的分配和使用动态内存的方法是调用一个名为 make_shared 的标准库函数。  
此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr 。  
与智能指针一样， make_shared 也定义在头文件 memory 中。
```c++
shared_ptr<int> pt = make_shared<int>(42); // pt 指向一个值为 42 的 int 的 shared_ptr
shared_ptr<string> p1 = make_shared<string>(3,'c'); // p1 指向一个值为 "999" 的字符串
```

我们可以认为每个 shared_ptr 都有一个关联的计数器，通常称其为引用计数(reference count)​。  
无论何时我们拷贝一个 shared_ptr ，计数器都会递增。
当我们给 shared_ptr 赋予一个新值或是 shared_ptr 被销毁(例如一个局部的 shared_ptr 离开其作用域时)，计数器就会递减。  
一旦一个 shared_ptr 的计数器变为 0 ，它就会自动释放自己所管理的对象。  

shared_ptr 的析构函数会递减它所指向的对象的引用计数。  
如果引用计数变为 0 ， shared_ptr 的析构函数就会销毁对象，并释放它占用的内存。
### (5.2) 动态内存
使用 new 动态分配和初始化对象。  
在自由空间分配的内存是无名的，因此 new 无法为其分配的对象命名，而是返回一个指向该对象的指针：  
```c++
int *p = new int; // p 指向一个动态分配的，未初始化的无名对象
```
默认情况下，动态分配的对象是默认初始化的，
这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化：  
```c++
string *ps = new string; // 初始化为空
int *p = new int; // p 指向一个未初始化的 int

// 也可以使用直接初始化
int *p1 = new int(99);
string *ps1 = new string(4,'8');
vector<int> *pv = new vector<int>{1,2,3};

// 也可以对动态分配的对象进行值初始化
int *p = new int; // 默认初始化为空
int *p1 = new int(); // 值初始化为 0
string *s = new string; // 默认初始化为空 string
string *s1 = new string(); // 值初始化为空 string
```

使用 delete 释放动态分配的对象， delete 接受一个指针，该指针指向想要释放的对象。  
delete 销毁给定的指针指向的对象，并释放对应的内存。  
我们传递给 delete 的指针必须指向动态分配的内存，或者是一个空指针​。  
释放一块并非 new 分配的内存，或者将相同的指针值释放多次，其行为是未定义的。  

使用 new 和 delete 常见的问题：
* 1、忘记 delete ，导致 "内存泄漏" ，一般是内存耗尽才会检测到该问题。  
* 2、使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。  
* 3、同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。  
如果对其中一个指针进行了 delete 操作，对象的内存就被归还给自由空间了。  
如果我们随后又 delete 第二个指针，自由空间就可能被破坏。  

**动态创建数组**  
使用 new 分配数组时，得到的不是数组对象，而是得到数组元素类型的指针。  
即使我们使用类型别名定义了一个数组类型，new 也不会分配一个数组类型的对象。  
在上例中，我们正在分配一个数组的事实甚至都是不可见的——连[num]都没有。  
new 返回的是一个元素类型的指针。  
由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或 end  
```c++
int *p = new int[4]; // 4 个未初始化的 int
int *p = new int[4](); // 4 个初始化为 0 的 int
```
### (5.3) 模板
1. 函数模板  
将函数模板的声明、实现和调用分开，需要注意调用实例化时，定义中要加上对应的实例声明
```c++
// head.h 是声明
template<typename T>
int compare(T v1,T v2);

// func.cpp 是定义
template<typename T>
int compare(T v1,T v2)
{
	if(v1 < v2) return 1;
	else return -1;
}
// 在其它函数中要调用该模板，必须在模板的定义中声明一个模板的实例，这里模板实例化为 int 类型就声明 int 类型
template int compare(int v1,int v2);

// main.cpp 调用 compare 函数
int main()
{
	int i = 2,j = 3;
	cout<< compare(i,j) <<endl; // 输出：1
	return 0;
}
```

2. 类模板  
## (6) 命名空间
多方合作开发的大型程序通常会面临名字冲突的问题，使用命名空间解决，每个命名空间就是一个作用域。  
定义：`namespace 空间名 {各种声明和定义}`  ，声明和定义用分号隔开  
命名空间可以不连续，即可以在多个位置添加定义。
```c++
namespace DSC
{
	int compare(int v1,int v2)
	{
		if (v1<v2)return 1;
		else return -1;
	}; // 使用分号隔开
	void hello(){cout<<"hello world"<<endl;}; // 使用分号隔开
}
```
在通常情况下，我们不把 #include 放在命名空间内部。  
如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。  

作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字。  
比如：`::user_name` 表示全局命名空间中的 user_name  

命名空间可以进行嵌套。  

未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。  
**在文件中进行静态声明的做法已经被 C++ 标准取消了，现在的做法是使用未命名的命名空间。**  

使用作用域运算符调用命名空间中的成员比较麻烦，可以使用 using 或给命名空间改一个简单的别名
```c++
namespace dsc_namespace{/* */}

// 1、使用 using ，之后可直接使用命名空间中的所有定义。避免使用。
using namespace dsc_namespace;

// 2、别名，之后可使用别名调用，可以有多个别名
namespace dsc_namespace = dsc;
dsc::hello(); // 使用别名调用
```

不建议使用 using 方法直接声明整个命名空间
用法简单但充满风险：一条语句就突然将命名空间中所有成员的名字变得可见了。如果应用程序使用了多个不同的库，而这些库中的名字通过 using 指示变得可见，则全局命名空间污染的问题将重新出现。  
相比于使用 using 指示，**在程序中对命名空间的每个成员分别使用 using 声明效果更好**，这么做可以减少注入到命名空间中的名字数量。  
using 声明引起的二义性问题在声明处就能发现，无须等到使用名字的地方，这显然对检测并修改错误大有益处。  

