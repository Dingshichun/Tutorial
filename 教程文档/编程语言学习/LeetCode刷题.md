# leetcode 刷题
## (1) 数组
### (1.1) 数组知识点
数组下标从 0 开始，**数组的元素不能删除，只能覆盖**。  
数组是存放在连续内存空间上的相同类型数据的集合。  
数组在内存空间的地址是连续的，在删除或者增添元素的时候，就难免要移动其他元素的地址。
### (1.2) 数组问题解法
* 1、二分法。典型就是在有序数组中查找某数
* 2、双指针或快、慢指针。删除数组重复元素，判断链表是否有环，合并链表等
* 3、滑动窗口。  
滑动窗口的精妙之处在于根据当前子序列和大小的情况，  
不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。
* 4、模拟行为。比如螺旋矩阵，顺时针输出矩阵的元素。
* 5、前缀和。求数组的区间和
## (2) 链表
### (2.1) 链表知识点
* 链表在内存中不是连续分布的，因为链表的指针域可以指向任何位置。
* **头指针** 具有标识作用，一般作为链表的名字，保存链表第一个结点的存储地址，链表的存取从头指针开始。每一个结点中都有数据域和指针域(next)，**指针域保存下一个结点的地址**，最后一个结点的指针域为空(nullptr)。  
**头指针必须存在，不然无法访问链表。**当链表没有头结点且没有存放元素的结点(是空链表)，头指针就为空(`head = nullptr;`)，此时的链表就没有什么意义。当链表有头结点且没有存放元素的结点(是空链表)，头指针保存的就是头结点的地址，然后头结点的指针域为空(`head->next = nullptr;`)  
* **头结点** 是为了操作的统一与方便而设立的，**放在第一个存放元素的结点之前**，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等），其指针域保存的就是第一个存放元素的结点的地址。  
**若链表有头结点，那么头指针就指向头结点(即头指针中保存的是头结点的地址)。**  
有了头结点后，对在第一个元素结点前插入结点和删除第一个结点，其操作与对其它结点的操作统一了。  
**头结点不是链表必须的，只是为了方便操纵链表而设置的。**  
**首元结点** ，即第一个存放元素的结点。如果存在头结点，首元节点就是头结点的后继结点。
```c++
// 链表结点的定义，可以不定义构造函数，系统会生成默认构造函数
struct ListNode {
    int val; // 数据域
    ListNode* next; // 指针域，存放的是下一个结点的地址
    ListNode() : val(0), next(nullptr) {} // 数据域和指针域都初始化为 0
    ListNode(int x) : val(x), next(nullptr) {} // 仅初始化数据域，指针域为空
    ListNode(int x, ListNode* next) : val(x), next(next) {} // 初始化数据域和指针域
};
```

**删除结点**：只需将要删除结点的前继结点指向要删除结点的后继结点即可。  
但是注意最好释放掉要删除结点指向的空间，不然可能会导致无法预料的内存问题。
```c++
// 比如要删除的结点是 cur, cur 的前继结点是 front ，后继结点是 behind
ListNode*temp=cur;  // 获取要删除结点的地址 ，ListNode 是结构体
front->next = behind; // 删除结点 cur
delete temp; // 释放被删除结点指向的空间
temp = nullptr; // 要将指针置空，不然其指向随机，会出现野指针问题
```
**添加结点**：先找到添加位置的前继结点，将添加结点指向添加位置的前继结点的后继结点，  
最后将添加位置的前继结点指向要添加的结点。

链表的查找只能从头开始，不方便。但是链表的增、删比较方便。  
所以链表适合数据量不固定，频繁增删，较少查询的场景。

### (2.2) 链表问题
当需要返回链表的第一个结点时，最好创建一个 **辅助的虚拟头结点**(其后继结点就是原链表的第一个数据结点)   
这样方便对原链表的第一个结点进行操作，比如删除第一个结点，或在第一个结点之前插入结点。    

设计一个链表的题目包含了链表的基本操作，如下：  
* 1、获取链表第 index 个节点的数值
* 2、在链表的最前面插入一个节点
* 3、在链表的最后面插入一个节点
* 4、在链表第 index 个节点前面插入一个节点
* 5、删除链表的第 index 个节点的数值

常见的链表问题如下：
* 1、反转链表。
* 2、删除倒数第 n 个结点
* 3、链表是否有环
* 4、两个链表是否相交

## (3) 哈希表(hash table)
### (3.1) 哈希表知识点
**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。**

哈希表是根据关键码的值而直接进行访问的数据结构。直白来讲其实数组也是一张哈希表。  
哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。  
那么哈希表能解决什么问题呢，一般哈希表都是用来快速判断一个元素是否出现集合里。  

哈希表就是通过特定的编码将其它数据格式转化为不同的数值，  
如果出现哈希碰撞(即不同的数据通过编码后转换为相同的数值)，那么就在该位置添加一个链表，  
冲突的数据依次存放在链表中。

常见的 3 种哈希结构是数组、set(集合)和 map(映射)。 
|集合|底层实现|是否有序|数值是否可以重复|能否更改数值|查询效率|增删效率|   
|:----|:-------|:--------|:--------------|:-----------|:-------|:--------|  
|std::set|红黑树|有序|否|否|O(log n)|O(log n)|  
|std::multiset|红黑树|有序|是|否|O(logn)|O(logn)|  
|std::unordered_set|哈希表|无序|否|否|O(1)|O(1)|  

|映射|底层实现|是否有序|数值是否可以重复|能否更改数值|查询效率|增删效率|
|:----|:-------|:--------|:--------------|:-----------|:-------|:--------| 
|std::map|红黑树|key有序|key不可重复|key不可修改|O(logn)|O(logn)|
|std::multimap|红黑树|key有序|key可重复|key不可修改|O(log n)|O(log n)|
|std::unordered_map|哈希表|key无序|key不可重复|key不可修改|O(1)|O(1)|

哈希法牺牲空间换取时间，因为我们要使用额外的数组， set 或者是 map 来存放数据，才能实现快速的查找。  

## (4) 二叉树
### (4.1) 知识点
**满二叉树**：二叉树只有度为 0 和 2 的结点，且度为 0 的结点在同一层，则为满二叉树。

**完全二叉树**：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。  

**二叉搜索树**：二叉搜索树是有序数。
* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉排序树

**平衡二叉搜索树**：又被称为 AVL(Adelson-Velsky and Landis) 树，  
且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1 ，并且左右两个子树都是一棵平衡二叉树。  

C++ 中 map、set、multimap ， multiset 的底层实现都是平衡二叉搜索树，所以 map、set 的增删操作时间时间复杂度是 logn ，    
unordered_map、unordered_set ， unordered_map、unordered_set 底层实现是哈希表。  

**二叉树可以链式存储，也可以顺序存储，常用链式存储。**   

### (4.2) 二叉树的遍历
* 1、深度优先遍历:先往深走，遇到叶子结点再返回。  
包括前序遍历(根左右)、中序遍历(左根右)和后序遍历(左右根) 。包括迭代法和递归法 
* 2、广度优先遍历: 一层一层地遍历。即层次遍历，迭代法   

### (4.3) 二叉树的定义
链式存储和顺序存储，顺序存储使用数组，链式存储类似链表，只是指针的个数多一点。   
链式存储的结点定义如下：
```c++
struct treeNode
{
    int val; // 数据域
    treeNode* left; // 左指针
    treeNode* right; // 右指针
    treeNode():val(0),left(nullptr),right(nullptr){} // 构造函数
    treeNode(int x):val(x),left(nullptr),right(nullptr){} // 有值构造
    treeNode(int x,treeNode* left,treeNode* right):val(x),left(left),right(right){} // 有值构造
};
```
### (4.4) 二叉树的递归遍历
对于递归，一般是一看就会，一写就废。  
要想正确写出递归，注意三要素：
* 1、**确定递归函数的参数和返回值** : 确定哪些参数是递归的过程中需要处理的，  
那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

* 2、**确定终止条件** : 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，  
就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，  
如果递归没有终止，操作系统的内存栈必然就会溢出。  

* 3、**确定单层递归的逻辑** : 确定每一层递归需要处理的信息。  
在这里也就会重复调用自己来实现递归的过程。

以前序遍历为例：
1、确定递归函数的参数和返回值：  
因为要打印出前序遍历节点的数值，  
所以参数里需要传入 vector 来放节点的数值，不需要有返回值，  
所以递归函数返回类型就是 void ，代码如下：
```c++
void traversal(TreeNode* cur, vector<int>& vec)
```
2、确定终止条件：  
在递归的过程中，如何算是递归结束了呢，  
当然是当前遍历的节点是空了，那么本层递归就要结束了，  
所以如果当前遍历的这个节点是空，就直接 return ，代码如下：
```c++
if (cur == NULL) return;
```
3、确定单层递归的逻辑：  
前序遍历是根左右的顺序，所以在单层递归的逻辑，是要先取根结点的数值，代码如下：
```c++
vec.push_back(cur->val);    // 根
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
```
前序遍历完整代码如下：
```c++
class Solution {
public:
    // 前序遍历
    void traversal(TreeNode* cur, vector<int>& vec) 
    {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 根
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }

    vector<int> preorderTraversal(TreeNode* root) 
    {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```
中序和后序如下：
```c++
// 中序遍历
void traversal(TreeNode* cur, vector<int>& vec) 
{
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 根
    traversal(cur->right, vec); // 右
}

// 后序遍历
void traversal(TreeNode* cur, vector<int>& vec) 
{
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 根
}
```
